<?php

echo "<h1>Домашне завдання з PHP - Пірков Олександра Володимирович.</h1>";
echo "<h2>Повторіть всі функції для масивів з власними прикладами.</h2>";
echo '<p><b>1.</b> Функція <b>count</b> вираховує кількість елементів <b>індексного (числового)</b> або <b>асоціативного (рядкові ідекси)</b> масивів.</p>';
//Функція вираховує кількість елементів індексного (числового) або асоціативного (рядкові ідекси) масивів.
$arr = [1, 2, 3, 4, 5, 'my', 'example'];
echo count($arr).'</br>';//7


echo '<p><b>2.</b> Функція <b>range</b> використовується для створення масиву, що містить діапазон чисел або символів. Вона приймає від одного до трьох аргументів та повертає масив.</p>';
var_dump(range('a', 'f'));//array(6) { [0]=> string(1) "a" [1]=> string(1) "b" [2]=> string(1) "c" [3]=> string(1) "d" [4]=> string(1) "e" [5]=> string(1) "f" }
echo '</br>';
var_dump(range(1, 60, 5));//array(12) { [0]=> int(1) [1]=> int(6) [2]=> int(11) [3]=> int(16) [4]=> int(21) [5]=> int(26) [6]=> int(31) [7]=> int(36) [8]=> int(41) [9]=> int(46) [10]=> int(51) [11]=> int(56) }
echo '</br>';


echo '<p><b>3.</b> Функція <b>array_sum</b> використовується для обчислення суми всіх числових значень масиві. 
Вона приймає масив чисел як аргумент і повертає суму всіх чисел у цьому масиві.</p>';
$arraySum = [1,2,3,4,5,6,7,8,9,10];
$ar = range(1, 10);
echo 'Сумма елементів масива $arraySum = [1,2,3,4,5,6,7,8,9,10] - '.array_sum($arraySum).'</br>';//55
echo 'Сумма елементів масива $ar = range(1, 10) - '.array_sum($ar).'</br>';//55

$str = 15798463245;
echo 'Сама всіх цифр данного числа 15798463245 дорівнює - '.array_sum(str_split($str, 1)).'</br>';//54


echo '<p><b>4.</b> Функція <b>array_product </b> використовується для обчислення добутку всіх числових значень у масиві. 
Вона приймає масив чисел як аргумент і повертає добуток всіх чисел у цьому масиві.</p>';
$arSum = [1,2,3,4,5,6,7,8,9,10];
$ar = range(1, 10);
echo 'Добуток всіх числових значень у масиві $arSum = [1,2,3,4,5,6,7,8,9,10] - '.array_product($arSum).'</br>'; //3628800
echo 'Добуток всіх числових значень у масиві $ar = range(1, 10) - '.array_product($ar).'</br>';//3628800


echo '<p><b>5.</b> Функція <b>array_slice</b> використовується для вилучення підмасиву (зрізу) із заданого масиву. 
Вона дозволяє вибрати певний діапазон елементів з вихідного масиву та повернути цей підмасив у новому масиві.</p>';
$ardss = [1, 2, 3, 4, 5, 6];
$str = ['Oleksadr', 'Pirkov', '1975'];
$rrr = array_slice($ardss, 2, 3);//false по замовченню ключі будуть переіндексовані з нуля
$rr = array_slice($ardss, 2, 3, true);//ключі елеметів будуть залишені 
$r = array_slice($str, 0, 2);
var_dump($rrr);//array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo '</br>';
var_dump($rr);//array(3) { [2]=> int(3) [3]=> int(4) [4]=> int(5) }
echo '</br>';
var_dump($r);//array(2) { [0]=> string(8) "Oleksadr" [1]=> string(6) "Pirkov" }


echo '<p><b>6.</b> Функція <b>array_merge</b> використовується для об\'єднання одного або кількох масивів у новий масив. 
Ця функція приймає кілька аргументів, кожен із яких є масивом, і повертає новий масив, у якому містяться всі 
елементи з переданих масивів. Якщо ключі повторюються в різних масивах, значення ключа в результуючому масиві 
буде взято з останнього масиву з таким ключем.</p>';
$arr = ['Мій', 'день', 'народження', "a"=>'There will be'];
$ardss = [5, 3, 2024, 'року', "a"=>'буде'];
var_dump(array_merge($arr, $ardss));//array(8) { [0]=> string(6) "Мій" [1]=> string(8) "день" [2]=> string(20) "народження" ["a"]=> string(8) "буде" [3]=> int(5) [4]=> int(3) [5]=> int(2024) [6]=> string(8) "року" }
echo '</br>';


echo '<p><b>7.</b> Функція <b>array_merge_recursive</b> використовується для рекурсивного об\'єднання двох або більше 
масивів, включаючи вкладені масиви. Це означає, що вона не лише поєднує значення на одному рівні масивів, але 
також рекурсивно поєднує вкладені масиви всередині масивів. Якщо ключі повторюються, значення об\'єднуються в відє масивів.</p>';
$arr = ['Мій', 'день', 'народження', "a"=>'There will be'];
$ardss = [5, 3, 2024, 'року', "a"=>'буде'];
var_dump(array_merge_recursive($arr, $ardss));//array(8) { [0]=> string(6) "Мій" [1]=> string(8) "день" [2]=> string(20) "народження" ["a"]=> array(2) { [0]=> string(13) "There will be" [1]=> string(8) "буде" } [3]=> int(5) [4]=> int(3) [5]=> int(2024) [6]=> string(8) "року" }


echo '<p><b>8.</b> Функція <b>array_reverse</b> Вона створює новий масив, в якому елементи вихідного масиву переставлені у зворотному порядку.</p>';
$array = range(1,20);
$arr = range(1, 20);
var_dump(array_reverse($array));//за замовченням другий параметр - false //array(20) { [0]=> int(20) [1]=> int(19) [2]=> int(18) [3]=> int(17) [4]=> int(16) [5]=> int(15) [6]=> int(14) [7]=> int(13) [8]=> int(12) [9]=> int(11) [10]=> int(10) [11]=> int(9) [12]=> int(8) [13]=> int(7) [14]=> int(6) [15]=> int(5) [16]=> int(4) [17]=> int(3) [18]=> int(2) [19]=> int(1) }
echo '</br>';
var_dump(array_reverse($arr, true));//array(20) { [19]=> int(20) [18]=> int(19) [17]=> int(18) [16]=> int(17) [15]=> int(16) [14]=> int(15) [13]=> int(14) [12]=> int(13) [11]=> int(12) [10]=> int(11) [9]=> int(10) [8]=> int(9) [7]=> int(8) [6]=> int(7) [5]=> int(6) [4]=> int(5) [3]=> int(4) [2]=> int(3) [1]=> int(2) [0]=> int(1) }
echo '</br>';

echo '<p><b>9.</b> Функція <b>array_flip</b> Вона створює новий масив, у якому ключі стають значеннями, а значення стають ключами. Ключі мають 
бути унікальними, оскільки ключі масиву мають бути унікальними, інакше виникне помилка.</p>';
$a = ['a'=> 'Hello', 'b' => 'people'];
var_dump(array_flip($a));//array(2) { ["Hello"]=> string(1) "a" ["people"]=> string(1) "b" }


echo '<p><b>10.</b> Функція <b>array_keys</b> використовується для вилучення ключів з асоціативного масиву та повернення їх у вигляді нового масиву.</p>';
$array = ['red'=>'червоний', 'green'=>'зелений', 'blue'=>'синій', 'bleak'=>'чорний'];
$keys = array_keys($array);
var_dump($keys);//array(4) { [0]=> string(3) "red" [1]=> string(5) "green" [2]=> string(4) "blue" [3]=> string(5) "bleak" }


echo '<p><b>11.</b> Функція <b>array_values</b> використовується для отримання всіх значень з масиву і повернення їх у вигляді нового індексованого
масиву. Ця функція перетворює асоціативний масив на звичайний індексований масив, який може бути корисним, якщо вам потрібно 
працювати зі значеннями масиву незалежно від їх ключів.</p>';
$array = ['a'=> 'Hello', 'b' => 'people', 5, 3];
$arrayNew = array_values($array);
var_dump($arrayNew);//array(4) { [0]=> string(5) "Hello" [1]=> string(6) "people" [2]=> int(5) [3]=> int(3) }

echo '<p><b>12.</b> Функція <b>array_combine</b> використовується для створення нового асоціативного масиву, використовуючи один 
масив для ключів та інший масив для значень. Вона приймає два масиви: перший масив містить ключі, а другий масив містить значення.</p>';
$key = ['q', 'r', 't', 'y'];
$element = ['234', '345','678','910'];
$a = array_combine($key, $element);
var_dump($a);//array(4) { ["q"]=> string(3) "234" ["r"]=> string(3) "345" ["t"]=> string(3) "678" ["y"]=> string(3) "910" }

echo '<p><b>13.</b> Функція <b>array_search</b> використовується для пошуку значення в масиві та повернення ключа, з яким це значення
асоційовано. Якщо значення не знайдено в масиві, то функція повертає false.</p>';
$element = ['a'=>'234', 's'=>'345','d'=>'678', 'f'=>'ви мій ключ шукаєте?'];
$key = array_search('ви мій ключ шукаєте?', $element);
if ($key !==false) {
    echo 'Знайдено в цьому масіві з ключем - '.$key.'</br>';//Знайдено в цьому масіві з ключем - f
}else{
    echo 'Значення в масиві не знайдено.'.'</br>';
}
var_dump($key);//string(1) "f"

echo '<p><b>14.</b> Функція <b>array_count_values</b> використовується для підрахунку кількості входжень кожного унікального значення 
в масиві та повертає асоціативний масив, де ключами є унікальні значення, а значеннями – кількість разів, яке це значення 
зустрічається у вихідному масиві.</p>';
$element = ['234', '345','345','people', 'people', 'people'];
$c = array_count_values($element);
var_dump($c);//array(3) { [234]=> int(1) [345]=> int(2) ["people"]=> int(3) }

echo '<p><b>15.</b> Функція <b>array_rand</b> Ця функція повертає випадковий ключ (або ключі) з масиву. Функція може також вибирати 
кілька випадкових ключів, якщо вказати другий аргумент - кількість ключів для вибору.</p>';
$element = ['234', '345','678','910', '1', '321', '456'];
$d = array_rand($element, 2);
var_dump($d);//array(2) { [0]=> int(2) [1]=> int(5) } - кожного разу значення будуть різні

echo '<p><b>15.</b> Функція <b>array_unique</b> використовується для видалення дублікатів із масиву та повертає новий масив з унікальними значеннями.</p>';
$el = ['234', '345', '678', '910', '234', '678'];
$e = array_unique($el);
var_dump($e);//array(4) { [0]=> string(3) "234" [1]=> string(3) "345" [2]=> string(3) "678" [3]=> string(3) "910" }

echo '<p><b>16.</b> Функція <b>array_filter</b> використовується для фільтрації елементів масиву на основі заданої користувачем 
функції. Вона повертає новий масив, в якому залишаються тільки елементи, для яких функція користувача повертає true.</p>';
function sum ($num) {
    if($num >=0){
        return true;
    }else{
        return false;
    }
}

$mas = [1,-5,9,0,3,10,-2,-15,45];
$result = array_filter($mas, 'sum');
var_dump($result);//array(6) { [0]=> int(1) [2]=> int(9) [3]=> int(0) [4]=> int(3) [5]=> int(10) [8]=> int(45) }

echo '<p><b>17.</b> Функція <b>array_key_exists</b> використовується для перевірки існування ключа в асоціативному масиві. 
Функція перевіряє, чи вказаний ключ в масиві, і повертає true, якщо ключ існує, або false, якщо ключ відсутній.</p>';
$key = ['q'=>'a', 'w'=>'r', 'e'=>'t', 'r'=>'y'];
$f = array_key_exists('w', $key);
$ff = array_key_exists('u', $key);
var_dump($f);//bool(true)
echo '</br>';
var_dump($ff);//bool(false)

echo '<p><b>18.</b> Функція <b>in_array</b> використовується для перевірки існування значення в асоціативному масиві. 
Функція перевіряє, чи вказане значення в масиві, і повертає true, якщо значення існує, або false, якщо значення відсутнє.</p>';
$key = ['q'=>'a', 'w'=>'r', 'e'=>'t', 'r'=>'y'];
$fa = in_array('a', $key);
$fb = in_array('w', $key);
var_dump($fa);//bool(true)
echo '</br>';
var_dump($fb);//bool(false)

echo '<p><b>19.</b> Функція <b>extract</b> використовується для імпорту змінних з асоціативного масиву до глобальної області 
видимості. Це може бути корисним, коли є асоціативний масив з даними, і необхідно створити змінні на основі ключів цього масиву. 
Таким чином, значення масиву стануть доступними як окремі змінні.</p>';
$eat = ['name'=>'Oleksandr', 'age'=>'48', 'country'=>'UA', 'lerning'=>'IT STEP'];
$g = extract($eat);
echo $name.'</br>';//Oleksandr
echo $age.'</br>';//48
echo $country.'</br>';//UA
echo $lerning.'</br>';//IT STEP

echo '<p><b>20.</b> Функція <b>implode</b> використовується для об\'єднання елементів масиву в рядок. Вона приймає два аргументи: 
роздільник (найчастіше це рядок) і сам масив. implode проходить елементами масиву, з\'єднує їх у один рядок, розділяючи їх зазначеним
роздільником, і повертає отриманий рядок. Альтернативна функція implode в PHP - це join, і обидві вони виконують те саме завдання. 
Можна використовувати implode та join взаємозамінно.</p>';
$mas = [1, 9, 29, 30];
$array = ['все', 'буде', 'добре'];
$t = implode('-', $mas);
$ar = implode(' ', $array);
echo $t.'</br>';//1-9-29-30
echo $ar.'</br>';//все буде добре

echo '<p><b>21.</b> Функція <b>array_chunk</b> використовується для поділу масиву на дрібніші підмасиви.</p>';
$mas = [1, 9, 29, 30, 51];
$h = array_chunk($mas, 2);
var_dump($h).'</br>';//array(3) { [0]=> array(2) { [0]=> int(1) [1]=> int(9) } [1]=> array(2) { [0]=> int(29) [1]=> int(30) } [2]=> array(1) { [0]=> int(51) } }

echo '<p><b>22.</b> Функція <b>array_push</b> використовується для додавання одного або більше елементів до кінця масиву. 
Вона змінює вихідний масив, додаючи нові елементи, які можуть бути скалярними значеннями, масивами чи об\'єктами.</p>';
$mas = [1, 5, 9, 0];
array_push($mas, 'xxx', 'yyy');
var_dump($mas).'</br>';//array(6) { [0]=> int(1) [1]=> int(5) [2]=> int(9) [3]=> int(0) [4]=> string(3) "xxx" [5]=> string(3) "yyy" }

echo '<p><b>23.</b> Функція <b>array_pad</b> використовується для доповнення масиву до певної довжини, додаючи вказане значення (заповнювач) масиву.</p>';
$mas = [1, 5, 9, 0];
$g = array_pad($mas, 8, 0);
$gg = array_pad($mas, -8, 0);
var_dump($g);//array(8) { [0]=> int(1) [1]=> int(5) [2]=> int(9) [3]=> int(0) [4]=> int(0) [5]=> int(0) [6]=> int(0) [7]=> int(0) }
echo '</br>';
var_dump($gg);//array(8) { [0]=> int(0) [1]=> int(0) [2]=> int(0) [3]=> int(0) [4]=> int(1) [5]=> int(5) [6]=> int(9) [7]=> int(0) }

echo '<p><b>24.</b> Функція <b>sort</b> призначена для сортування елементів масиву у порядку зростання (за значеннями). Вона змінює 
порядок елементів у вихідному масиві, переставляючи їх те щоб вони йшли гаразд від найменшого до найбільшому (для числових значень) 
чи алфавітному порядку (для рядків).</p>';
$numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
$str = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'z', 'x', 'c', 'v', 'b', 'n'];
sort($numbers);//відсортує та змінить елемети в ісходному масиві
$sorted = $numbers;
sort($sorted);//відсортує та змінить елемети в скопійованому масиві, а ісходний масив залишиться без змін
$strNew = $str;
sort($strNew);//відсортує та змінить елемети в скопійованому асоціативному масиві, а ісходний масив залишиться без змін
echo 'Відсортує та змінить елемети в <b>ісходному масиві:</b></br>';
print_r($numbers);//Array ( [0] => 1 [1] => 1 [2] => 2 [3] => 3 [4] => 3 [5] => 4 [6] => 5 [7] => 5 [8] => 5 [9] => 6 [10] => 9 )
echo '</br>';
echo '</br>';
echo 'Відсортує та змінить елемети в <b>скопійованому масиві</b>, а ісходний масив залишиться без змін:</b></br>';
print_r($sorted);//Array ( [0] => 1 [1] => 1 [2] => 2 [3] => 3 [4] => 3 [5] => 4 [6] => 5 [7] => 5 [8] => 5 [9] => 6 [10] => 9 )
echo '</br>';
echo '</br>';
echo 'Відсортує та змінить елемети в <b>скопійованому асоціативному масиві</b>, а ісходний масив залишиться без змін:</b></br>';
print_r($strNew);//Array ( [0] => a [1] => b [2] => c [3] => d [4] => f [5] => g [6] => h [7] => j [8] => k [9] => n [10] => s [11] => v [12] => x [13] => z )


echo '<p><b>25.</b> Функція <b>array_intersect</b> використовується для знаходження перетину елементів між двома чи більше масивами. 
Вона повертає новий масив, що містить лише ті елементи, які є у <b>ВСІХ!!!</b> переданих масивах.</p>';
$a = ['d', 'r', 'j', 'y', '5'];  
$b = ['2', '5', '2', 't', 'y']; 
$numbers =  range(1, 25);
$array = array_intersect($a, $b, $numbers);
var_dump($array);//array(1) { [4]=> string(1) "5" }


echo '<p><b>26.</b> Функція <b>shuffle</b> використовується для випадкового перемішування елементів масиву.</p>';
$arr = range(1, 10); 
$str = ['one', 'two', 'three', 'four', 'five'];
shuffle($arr); // випадково перемішає елементи індексного масиву 
shuffle($str); // випадково перемішає елементи асоціативого масиву 
echo 'Випадково перемішає елементи <b>індексного масиву:</b></br>';
var_dump($arr);
echo '</br>';
echo '</br>';
echo 'Випадково перемішає елементи <b>асоціативого масиву:</b></br>';
var_dump($str);


echo '<p><b> ЕКЗАМЕН.</b></p>';
echo '<p><b>Завдання 1. Функція fmod.</b>  Функция fmod (или "floating-point remainder") обычно используется для вычисления остатка 
от деления двух чисел с плавающей запятой. Она предоставляет более точный результат по сравнению с оператором % (остаток от деления) 
для чисел с плавающей точкой.</p>';
echo'<p>Зробити программу, яка з чисел 20...45 знаходила ті, які діляться на 5 і знайдіть суму цих чисел. Викоростати функцію fmod.</p>';

$sum = 0;

for ($i = 20; $i <= 45; $i++) {
    if (fmod($i, 5) == 0) {
        echo "$i діляться на 5.<br>";
        $sum += $i;
    }
}

echo "Сума цих чисел: $sum";

echo '<p><b>Завдання 2 функція shortestAngleBetweenClockHands.</b> Дано час у форматі hh:mm. Знайдіть найкоротший кут між годинниковою та хвилинною стрілками на аналоговому 
годиннику. </p>';

function shortestAngleBetweenClockHands($hours, $minutes) {
    $hourAngle = 0.5 * (60 * $hours + $minutes);
    $minuteAngle = 6 * $minutes;

    $angle = abs($hourAngle - $minuteAngle);//abc возвращает модуль числа

    // Найменший кут між стрілками (враховуючи обертання годинникової стрілки)
    $angle = min(360 - $angle, $angle);

    return $angle;
}

// Приклад виклику функції
$hours = 12;
$minutes = 25;

$shortestAngle = shortestAngleBetweenClockHands($hours, $minutes);
echo "Найкоротший кут між годинниковою та хвилинною стрілками для $hours:$minutes = $shortestAngle градусів";


echo '<p><b>Завдання 3 функція compareConcatenatedNumbers та функція findLargestConcatenatedNumber.</b> 
На вхід подаеться рядок цілих чисел, розділених пробілами. Знайдіть найбільше число,
складене шляхом конкатенації цих чисел один до одного.</p>';

function compareConcatenatedNumbers($a, $b) {
    // Об'єднання чисел в обидва порядки і порівняння
    $ab = $a . $b;
    $ba = $b . $a;

    return strcmp($ba, $ab); // порівняння у зворотньому порядку
}

function findLargestConcatenatedNumber($numbers) {
    usort($numbers, 'compareConcatenatedNumbers');
    return implode('', $numbers);
}

// Приклад виклику функції
$inputString = "38 146 589 93";
$numbers = explode(' ', $inputString);

$largestConcatenatedNumber = findLargestConcatenatedNumber($numbers);

echo "Найбільше число, складене шляхом конкатенації: $largestConcatenatedNumber";


echo '<p><b>Завдання 4 функція generateCombinations та рекурсивна функція printCombinations.</b> На вхід подаеться рядок цілих унікальних чисел, що не повторюються, розділених пробілами
(elements). Наступний рядок містить кількість елементів у комбінації (k). 1 <= k <= кількість елементів. Знайдіть
усі можливі комбінації заданої довжини. Виведіть їх у будь якому порядку.</p>';

function printCombinations($arr, $n, $k, $index, $data, $i) {
    // Якщо всі елементи комбінації вибрані, виведіть комбінацію
    if ($index == $k) {
        echo implode(' ', $data) . "\n";
        return;
    }

    // Виберіть поточний елемент і викликайте рекурсивно для наступних позицій
    while ($i < $n) {
        $data[$index] = $arr[$i];
        printCombinations($arr, $n, $k, $index + 1, $data, $i + 1);
        $i++;
    }
}

// Функція для виведення всіх можливих комбінацій
function generateCombinations($arr, $k) {
    $n = count($arr);
    $data = array_fill(0, $k, 0);

    printCombinations($arr, $n, $k, 0, $data, 0);
}

// Приклад виклику функції
$inputNumbers = "1 2 3 4 5";
$inputK = 2;

$numbers = explode(' ', $inputNumbers);
generateCombinations($numbers, $inputK);

// У цьому прикладі функція generateCombinations визначає масив унікальних чисел та довжину комбінації, 
// а потім викликає рекурсивну функцію printCombinations, яка виводить всі можливі комбінації заданої довжини.


echo '<p><b>Завдання 5 функція findMaxSubarraySum.</b> На вхід подається рядок чисел, розділених проблами. Потрібно знайти послідовність
чисел, що підуть поспіль, у якої сума елементів буде максимальною. 
Наприклад: для рядка "-2 1 -3 4 -1 2 1 -5 4" рішенням буде послідовність "4 -1 2 1" з максимальною сумою елементів,
що дорівнює "6". Вивести потрібно максимальну суму поспіль елементів, що йдуть. Потрібно врахувати, що послідовність
може бути лише одне число (дивіться приклад з негативними числами).</p>';

function findMaxSubarraySum($arr) {
    $maxEndingHere = $maxSoFar = $arr[0];

    for ($i = 1; $i < count($arr); $i++) {
        // Здійснюємо вибір між додаванням поточного елементу до попередньої суми і використанням поточного елементу як початку нової підпослідовності
        $maxEndingHere = max($arr[$i], $maxEndingHere + $arr[$i]);

        // Зберігаємо максимальну суму підпослідовності
        $maxSoFar = max($maxSoFar, $maxEndingHere);
    }

    return $maxSoFar;
}

// Приклад виклику функції
$inputNumbers = "-2 1 -3 4 -1 2 1 -5 4";
$numbers = array_map('intval', explode(' ', $inputNumbers));

$maxSubarraySum = findMaxSubarraySum($numbers);

echo "Максимальна сума послідовності: $maxSubarraySum";

// У цьому коді функція findMaxSubarraySum обчислює максимальну суму послідовності за допомогою Kadane's algorithm. 
// При виклику цієї функції з введеними числами виводиться максимальна сума послідовності.

echo '<p><b>Завдання 6. Функція getZodiacSign.</b> На вхід подається  датою у форматі ДД.ММ.РРРР (приклад: 15.04.1452). Виведить знак 
зодіаку цього дня. Інтервали у вигляді масиву для зручності.</p>';

function getZodiacSign($day, $month) {
    $signs = array(
        array("name" => "Овен", "start" => array(21, 3), "end" => array(20, 4)),
        array("name" => "Телець", "start" => array(21, 4), "end" => array(20, 5)),
        array("name" => "Близнюки", "start" => array(21, 5), "end" => array(21, 6)),
        array("name" => "Рак", "start" => array(22, 6), "end" => array(22, 7)),
        array("name" => "Лев", "start" => array(23, 7), "end" => array(22, 8)),
        array("name" => "Діва", "start" => array(23, 8), "end" => array(22, 9)),
        array("name" => "Терези", "start" => array(23, 9), "end" => array(22, 10)),
        array("name" => "Скорпіон", "start" => array(23, 10), "end" => array(21, 11)),
        array("name" => "Стрілець", "start" => array(22, 11), "end" => array(21, 12)),
        array("name" => "Козеріг", "start" => array(22, 12), "end" => array(20, 1)),
        array("name" => "Водолій", "start" => array(21, 1), "end" => array(19, 2)),
        array("name" => "Риби", "start" => array(20, 2), "end" => array(20, 3))
    );

    foreach ($signs as $sign) {
        $startDay = $sign['start'][0];
        $startMonth = $sign['start'][1];
        $endDay = $sign['end'][0];
        $endMonth = $sign['end'][1];

        if (($month == $startMonth && $day >= $startDay) || ($month == $endMonth && $day <= $endDay)) {
            return array(
                'name' => $sign['name'],
                'period' => sprintf("%02d.%02d - %02d.%02d", $startDay, $startMonth, $endDay, $endMonth)
            );
        }
    }

    return "Не знайдено знак зодіаку для введеної дати.";
}

// Приклад виклику функції
$dateInput = "05.03.1975";
list($day, $month, $year) = sscanf($dateInput, "%d.%d.%d");

$zodiacSignInfo = getZodiacSign($day, $month);

if (is_array($zodiacSignInfo)) {
    echo "Знак зодіаку для $dateInput: {$zodiacSignInfo['name']}, період {$zodiacSignInfo['period']}";
} else {
    echo $zodiacSignInfo;
}

// У цьому коді функція getZodiacSign повертає масив з інформацією про знак зодіаку, який містить ім'я знака 
// та його період у вигляді рядка "число.місяць - число.місяць". Якщо знак зодіаку не знайдено, повертається 
// відповідне повідомлення.


echo '<p><b>Завдання 7. Функція getCorrectForm.</b> Потрібно написати код, який прийматиме на вхід число і 3 форми слова - 3
відмінювання в залежності від числа, з яким вони вживаються в мові. Наприклад: яблуко (одне), яблука (три),
яблук (п`ять). Залежно від числа потрібно вибрати правильну форму слова та вивести на екран фразу з числа та слова. 
На вхід подається 4 рядки:
1.число
2. слово в однені (одне яблуко)
3. слово у множені, коли йдеться про два об`єкти (два яблука)
4. слово у множені, коли йдеться про п`ять об`єктів (п`ять яблук)
Вивести потрібно число і слово у правильному відмінованні, розділені пробілами.</p>';

function getCorrectForm($number, $singular, $pluralTwo, $pluralFive) {
    $result = '';

    if ($number == 1) {
        $result = "$number $singular";
    } elseif ($number >= 2 && $number <= 4) {
        $result = "$number $pluralTwo";
    } elseif ($number >= 5 || $number == 0) {
        $result = "$number $pluralFive";
    }

    return $result;
}

// Приклад виклику функції
$number = 5;
$singularForm = "яблуко";
$pluralTwoForm = "яблука";
$pluralFiveForm = "яблук";

$resultPhrase = getCorrectForm($number, $singularForm, $pluralTwoForm, $pluralFiveForm);

echo $resultPhrase;

// У цьому коді функція getCorrectForm приймає число та три форми слова: для одного об'єкта, для двох об'єктів 
// та для п'яти об'єктів. Функція визначає правильну форму слова в залежності від числа та повертає рядок, який 
// складається з числа та відповідної форми слова.

echo '<p><b>Завдання 8. Функція isLuckyTicket, функція findLuckyTicketsInRange.</b> Щасливий квиток - коли сума перших трьох цифр у номері квитка дорівнює сумі другої
трійки цифр (номер шестизначний). Приклад: 123015 - щасливий, оскільки сума кожної половини дорівнює 6.
На вхід подається 2 рядки:
1. Початковий номер квитка (наприклад: 111111)
2. кінцевий номер квитка (наприклад: 123321)
Потрібно вивести всі щасливі квитки із заданного діапазону.</p>';

function isLuckyTicket($number) {
    // Перевірка, чи є квиток щасливим
    $digits = str_split($number);//розбіває строку на масив символів (подстрок) на основі заданої дліни
    $halfLength = count($digits) / 2;//полудліна
    $firstHalfSum = array_sum(array_slice($digits, 0, $halfLength));//перша полудліна
    $secondHalfSum = array_sum(array_slice($digits, $halfLength));//друга полудліна

    return $firstHalfSum == $secondHalfSum;
}

function findLuckyTicketsInRange($start, $end) {
    // Знаходження всіх щасливих квитків у заданому діапазоні
    $luckyTickets = array();

    for ($i = $start; $i <= $end; $i++) {
        if (isLuckyTicket($i)) {
            $luckyTickets[] = $i;
        }
    }

    return $luckyTickets;
}

// Приклад виклику функції
$startTicket = 111111;
$endTicket = 123321;

$luckyTicketsInRange = findLuckyTicketsInRange($startTicket, $endTicket);
$countOfLuckyTickets = count($luckyTicketsInRange);

echo "<b>Щасливі квитки у діапазоні від $startTicket до $endTicket:</b> " . implode(", ", $luckyTicketsInRange) . "\n".'</br>';
echo "<b>Кількість щасливих квитків: $countOfLuckyTickets.</b>";

// У цьому коді функція isLuckyTicket перевіряє, чи є номер квитка щасливим, а функція findLuckyTicketsInRange 
// знаходить всі щасливі квитки у заданому діапазоні. Переменная $countOfLuckyTickets, чтобы хранить количество 
// счастливых билетов, и вывел ее в конце.


echo '<p><b>Завдання 9.</b> МАКСИМАЛЬНИЙ ПРИБУТОК. Дано список, що містить прогноз майбутніх цін на акції. Знайдіть
максмальний прибуток, який можна отримати, купуючи та продаючи акції будь-яку кількість разів з обмеженням, що
нова транзакція може розпочатися лише після завершення попередній.
Наприклад.
Ціна на акції: 1 3 2 1 7
Купуємо на 1 день і продаємо на 2 день
Купуємо на 4 день і продаємо на 5 день
Максимальний прибуток: 7
</p>';

function maxProfit($prices) {
    $profit = 0;

    for ($i = 1; $i < count($prices); $i++) {
        // Якщо ціна підніметься, додаємо різницю до прибутку
        if ($prices[$i] > $prices[$i - 1]) {
            $profit += $prices[$i] - $prices[$i - 1];
        }
    }

    return $profit;
}

// Приклад виклику функції
$stockPrices = array(1, 3, 2, 1, 7);
$result = maxProfit($stockPrices);

echo "Максимальний прибуток: $result";

// Цей код пройде через список цін акцій та додасть різницю між сусідніми цінами до прибутку, якщо ціна підвищиться.
// Таким чином, він враховує всі транзакції, де можливий прибуток.

echo '<p><b>Завдання 10. Функція mb_substr та функція mb_substr.</b> Виділіть з рядка "Іван_Іванів" ім`ята прізвище та виведіть іх на екран. Використовуйте
для пошуку позиції першого вхоження роздільника у рядок функцію mb_strpost(), а для отримання необхідних підрядок
функцію mb_substr(). Знову ж таки, обов`язково дивіться опис функцій у відповідному розділі офіційного овідника.</p>';

$string = "Іван_Іванів";

// Знаходимо позицію роздільника "_"
$separatorPosition = mb_strpos($string, "_");

if ($separatorPosition !== false) {
    // Витягуємо ім'я та прізвище за допомогою mb_substr()
    $name = mb_substr($string, 0, $separatorPosition);
    $surname = mb_substr($string, $separatorPosition + 1);

    // Виводимо результат на екран
    echo "Ім'я: $name\n";
    echo "Прізвище: $surname\n";
} else {
    echo "Роздільник не знайдено в рядку.\n";
}


echo '<p><b>Завдання 11. Функція match_letter()</b> Створіть функцію match_letter(), яка в якості першого аргументу
прийматиме рядок $str і перевірятиме її на відповідність допустимим символам масиву $alphabet, який буде передаватися
як другий аргумент. Результат перевірки функція має виводити на екран.
Перевірте за допомогою цієї функції на наявність заборонених символів рядки "s-1", "S_20" і "3_S", якщо масивом
допустимих символів передається масив ["s", "1","2", "3"] .), а також внутрішній цикл for по всіх елементах масиву
(кількість елементів масиву можна дізнатися за допомогою count() ). У внутрішньому циклі слід порівнювати поточний
символ рядка з усіма символами масиву, щоб встановити його допустиміть. </p>';

// function match_letter($str, $alphabet) {
//     // Перевірка кожного символу рядка на відповідність допустимим символам
//     for ($i = 0; $i < mb_strlen($str); $i++) {
//         $currentChar = mb_substr($str, $i, 1);

//         // Перевірка, чи поточний символ є допустимим
//         $isValid = false;
//         for ($j = 0; $j < count($alphabet); $j++) {
//             if ($currentChar === $alphabet[$j]) {
//                 $isValid = true;
//                 break;
//             }
//         }

//         // Виведення результату перевірки на екран
//         echo "Символ '$currentChar' " . ($isValid ? "допустимий" : "заборонений") . "\n";
//     }
// }

// // Масив допустимих символів
// $allowedCharacters = ["s", "1", "2", "3"];

// // Рядки для перевірки
// $stringsToCheck = ["s-1", "S_20", "3_S"];

// // Перевірка кожного рядка за допомогою функції
// foreach ($stringsToCheck as $string) {
//     echo "Перевірка рядка: \"$string\"\n";
//     match_letter($string, $allowedCharacters);
//     echo "-----------------------------\n";
// }

// // Ця функція пройде крізь кожен символ рядка та порівняє його з усіма символами масиву $alphabet, виводячи на екран,
// // чи є поточний символ допустимим чи забороненим. Результати перевірки для кожного символу виводяться на екран.
// // Функція match_letter() виконує наступні завдання:
// // Параметри функції:
// // $str: Рядок, який перевіряється на відповідність допустимим символам.
// // $alphabet: Масив, який містить допустимі символи.
// // Основна логіка функції:
// // За допомогою циклу for перебирається кожен символ рядка $str.
// // Внутрішнім циклом for порівнюється поточний символ з усіма символами масиву $alphabet.
// // Результати перевірки виводяться на екран.
// // Вивід на екран:
// // Для кожного символу рядка виводиться повідомлення про те, чи є він допустимим або забороненим символом.
// // Використання функції:
// // Функцію можна використовувати для перевірки кожного символу в заданому рядку на його допустимість відносно переданого масиву $alphabet.
// // Результат:
// // Результатом роботи функції є вивід на екран для кожного символу з рядка, вказуючи, чи є він допустимим або забороненим символом згідно з переданим масивом.
// // Застереження:
// // Функція не повертає значення, а лише виводить результат на екран. Якщо потрібно отримати результати для подальшого використання, можна внести відповідні зміни.


// echo '<p><b>Завдання 12. Функція move_uploaded_file().</b>  Створіть форму, склад та зовнішній вигляд полів якої показано на скріншоті. Код,
// який оброблятиме дані форми на сервері, повинен перивіряти заповнення полів імені та прізвища та у разі помилки
// виводити попередження та переривати. Що стосується аватарки, то скрипт повинен або вивести аватарку після імені та
// прізвища, або повідомити про незавантажену аватарку (див. скріншот завдвння: форма та кнопки ліворуч, а результат - 
// праворучь від форми, при цьому над виведеним результатом виводиться "Результат", а під іменім та призвищем - виводиться аватарка). Для отримання імені, розміру та 
// тимчасової папки для зберіання завантажених фалів використовуйте суперглобальний масив $_FILES. Для переміщення
// завантаженої аватарки в цільову папку використовуйте функцію move_uploaded_file() (як цільову створіть папку 
// avatars). Щоб правильно вказати шлях до аватарки, що вставляється на сторінку, не забудьте почати його з 
// http://localhost/test/ . При бажанні можете додати перевірку аватари, що завантажується на відповідність типу
// зображення і т.д.</p>'; 
// ?>
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Форма з аватаркою</title>
// </head>
// <body>
//     <form action="upload.php" method="post" enctype="multipart/form-data">
//         <label for="first_name">Ім'я:</label>
//         <input type="text" name="first_name" required><br>

//         <label for="last_name">Прізвище:</label>
//         <input type="text" name="last_name" required><br>

//         <label for="avatar">Аватарка:</label>
//         <input type="file" name="avatar" accept="image/*" required><br>

//         <input type="submit" value="Завантажити">
//     </form>
    

// <?php
// // Перевірка, чи отримано POST-запит
// if ($_SERVER["REQUEST_METHOD"] === "POST") {
//     // Перевірка, чи вказані ім'я та прізвище
//     if (empty($_POST["first_name"]) || empty($_POST["last_name"])) {
//         echo "Попередження: Будь ласка, введіть ім'я та прізвище.";
//         die(); // Зупиняє виконання скрипта
//     }

//     // Перевірка, чи вказано файл
//     if (!isset($_FILES["avatar"])) {
//         echo "Попередження: Не вибрано аватарку.";
//         die();
//     }

//     $firstName = $_POST["first_name"];
//     $lastName = $_POST["last_name"];

//     // Перевірка типу файлу та збереження аватарки
//     $targetDirectory = "avatars/";
//     $targetFile = $targetDirectory . basename($_FILES["avatar"]["name"]);
//     $imageFileType = strtolower(pathinfo($targetFile, PATHINFO_EXTENSION));

//     if ($_FILES["avatar"]["size"] > 500000) {
//         echo "Попередження: Файл завеликий.";
//         die();
//     }

//     // Дозволені формати зображень
//     $allowedFormats = array("jpg", "jpeg", "png", "gif");

//     if (!in_array($imageFileType, $allowedFormats)) {
//         echo "Попередження: Допустимі лише JPG, JPEG, PNG та GIF формати.";
//         die();
//     }

//     if (move_uploaded_file($_FILES["avatar"]["tmp_name"], $targetFile)) {
//         // Виведення результатів та аватарки
//         echo "<h2>Результат</h2>";
//         echo "<p>Ім'я: $firstName</p>";
//         echo "<p>Прізвище: $lastName</p>";
//         echo "<p><img src='http://localhost/domains/test/$targetFile' alt='Аватарка'></p>";
//     } else {
//         echo "Помилка при завантаженні файлу.";
//     }
// }
// ?>
// </body>
// </html>
